{% load staticfiles %}

<script src="{% static 'battle/js/three.min.js' %}"></script>
<script src="{% static 'battle/js/OrbitControls.js' %}"></script>


<script type="text/javascript">

    var regions = {{ regions|safe }};

    function load_map(canvas_container, regions, region_callback, settlement_callback) {
        var viewWidth = canvas_container.width();
        var viewHeight = canvas_container.height();

        //scene
        var scene = new THREE.Scene();
        //camera
        var camera = new THREE.PerspectiveCamera(75, viewWidth / viewHeight, 0.1, 1000);
        camera.position.z = 0;
        camera.position.x = 0;
        camera.position.y = 8;
        camera.lookAt(new THREE.Vector3( 0, 0, 0 ));
        camera.aspect = viewWidth / viewHeight;
        camera.updateProjectionMatrix();

        //renderer
        var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(viewWidth, viewHeight);
        renderer.setClearColor( 0xffffff, 0);
        //controls
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        //axes
        // var axes = new THREE.AxisHelper(2);
        // scene.add(axes);
        //grid xz
        // var gridXZ = new THREE.GridHelper(10, 1);
        // scene.add(gridXZ);
        //ambient light
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        //directional light
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        // point light
        //var pointLight = new THREE.PointLight(0xffffff, 10);
        //pointLight.position.set(0, 10, 30);
        //scene.add(pointLight);

        //show canvas

        canvas_container.html(renderer.domElement);

        var region_geometry = new THREE.CubeGeometry(1, 1, 1);
        var region_materials = {
            "plains": new THREE.MeshLambertMaterial({color: 0x90CD00, shading: THREE.SmoothShading}),
            "forest": new THREE.MeshLambertMaterial({color: 0x207F07, shading: THREE.SmoothShading}),
            "shore": new THREE.MeshLambertMaterial({color: 0x0D81CD, shading: THREE.SmoothShading}),
            "deepsea": new THREE.MeshLambertMaterial({color: 0x000E85, shading: THREE.SmoothShading}),
            "mountain": new THREE.MeshLambertMaterial({color: 0x837D71, shading: THREE.SmoothShading}),
        };

        for (var i = 0; i < regions.length; i++)  {
            var region = regions[i];
            var mesh = new THREE.Mesh(region_geometry, region_materials[region.type]);

            var geo = new THREE.EdgesGeometry( mesh.geometry ); // or WireframeGeometry
            var mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 1 } );
            var wireframe = new THREE.LineSegments( geo, mat );
            mesh.add( wireframe );

            mesh.position.x = region.x_pos - 1;
            mesh.position.z = region.z_pos - 1;
            mesh.position.y = region.y_pos;

            regions[i].mesh = mesh;
            mesh.region = regions[i];

            scene.add(mesh);

            for (var j = 0; j < region.settlements.length; j++) {
                var settlement = region.settlements[j];

                radius = Math.log10(settlement.population) * 0.02;
                var settlement_geometry = new THREE.CylinderGeometry( radius, radius, 0.01, 16 );
                var settlement_material = new THREE.MeshBasicMaterial( {color: 0x000000} );

                var cylinder = new THREE.Mesh( settlement_geometry, settlement_material );
                cylinder.position.x = (region.x_pos - 1) - 0.5 + settlement.x_pos/100;
                cylinder.position.z = (region.z_pos - 1) - 0.5 + settlement.z_pos/100;
                cylinder.position.y = region.y_pos + 0.5;

                cylinder.settlement = settlement;
                regions[i].settlements[j].mesh = cylinder;

                scene.add(cylinder);
            }

            window.addEventListener( 'resize', onWindowResize, false );
        }


        var raycaster = new THREE.Raycaster();

        var mouse = new THREE.Vector2();

        function onMouseMove( event ) {

            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components

            var el = canvas_container.offset();
            mouse.x = ( (event.clientX - el.left) / viewWidth ) * 2 - 1;
            mouse.y = - ( (event.clientY - el.top) / viewHeight ) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = canvas_container.width() / canvas_container.height();
            camera.updateProjectionMatrix();
            renderer.setSize( canvas_container.width(), canvas_container.height() );
        }

        //render scene
        function render() {
            raycaster.setFromCamera( mouse, camera );

            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects( scene.children );
            var region_intersected = false;
            var settlement_intersected = false;

            for ( var i = 0; i < intersects.length; i++ ) {

                var region = intersects[ i ].object.region;
                if (region !== undefined && !region_intersected) {
                    region_callback(region);
                    region_intersected = true;
                }
                var settlement = intersects[ i ].object.settlement;
                if (settlement !== undefined && !settlement_intersected) {
                    settlement_callback(settlement);
                    settlement_intersected = true;
                }

            }

            if (!settlement_intersected) settlement_callback(undefined);
            if (!region_intersected) region_callback(undefined);

            requestAnimationFrame(render);
            renderer.render(scene, camera);
        };

        function animate(){
            requestAnimationFrame(animate);
        }

        animate();
        render();

        canvas_container.mousemove(onMouseMove);

    }

</script>
